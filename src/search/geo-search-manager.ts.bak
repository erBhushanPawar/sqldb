/**
 * Geographic search manager - combines text search with geospatial capabilities
 */

import { RedisConnectionManager } from '../connection/redis';
import {
  GeoPoint,
  GeoDistance,
  GeoSearchOptions,
  GeoSearchResult,
  GeoSearchTableConfig,
  GeoBucket,
  GeoBounds,
  GeoIndexStats,
  MAJOR_CITY_BUCKETS,
} from '../types/geo-search';
import {
  calculateDistance,
  isWithinRadius,
  calculateBounds,
  findBucket,
  isValidCoordinates,
  calculateCenterPoint,
  calculateBoundingBox,
} from './geo-utils';
import { LocationNormalizer, US_CITY_ALIASES, INTERNATIONAL_CITY_ALIASES } from './location-normalizer';

export interface GeoIndexedDocument {
  id: string | number;
  location: GeoPoint;
  data: any;
  locationName?: string;
  bucketId?: string;
}

export class GeoSearchManager {
  private redis: RedisConnectionManager;
  private tableName: string;
  private config: GeoSearchTableConfig;
  private locationNormalizer: LocationNormalizer;
  private indexKeyPrefix: string;

  constructor(
    redis: RedisConnectionManager,
    tableName: string,
    config: GeoSearchTableConfig
  ) {
    this.redis = redis;
    this.tableName = tableName;
    this.config = config;
    this.indexKeyPrefix = `geo:${tableName}`;

    // Initialize location normalizer with buckets and mappings
    const buckets = config.buckets || MAJOR_CITY_BUCKETS;
    const mappings = [
      ...(config.locationMappings || []),
      ...US_CITY_ALIASES,
      ...INTERNATIONAL_CITY_ALIASES,
    ];
    this.locationNormalizer = new LocationNormalizer(buckets, mappings);
  }

  /**
   * Index a document with geographic data
   */
  async indexDocument(doc: GeoIndexedDocument): Promise<void> {
    if (!isValidCoordinates(doc.location)) {
      throw new Error(`Invalid coordinates for document ${doc.id}: ${JSON.stringify(doc.location)}`);
    }

    const client = await this.redis.getClient();
    const pipeline = client.pipeline();

    // 1. Add to main geo index using Redis GEOADD
    const mainGeoKey = `${this.indexKeyPrefix}:main`;
    pipeline.geoadd(mainGeoKey, doc.location.lng, doc.location.lat, String(doc.id));

    // 2. Store document data
    const docKey = `${this.indexKeyPrefix}:doc:${doc.id}`;
    pipeline.set(docKey, JSON.stringify({
      ...doc.data,
      _geo_lat: doc.location.lat,
      _geo_lng: doc.location.lng,
      _geo_location_name: doc.locationName,
      _geo_bucket_id: doc.bucketId,
    }));

    // 3. Add to bucket index if applicable
    if (doc.bucketId) {
      const bucketKey = `${this.indexKeyPrefix}:bucket:${doc.bucketId}`;
      pipeline.sadd(bucketKey, String(doc.id));
    } else if (this.config.buckets) {
      // Auto-assign bucket
      const bucket = findBucket(doc.location, this.config.buckets);
      if (bucket) {
        const bucketKey = `${this.indexKeyPrefix}:bucket:${bucket.id}`;
        pipeline.sadd(bucketKey, String(doc.id));
        // Update document with bucket ID
        pipeline.hset(docKey, '_geo_bucket_id', bucket.id);
      }
    }

    // 4. Add to location name index if provided
    if (doc.locationName && this.config.autoNormalize) {
      const normalized = this.locationNormalizer.normalize(doc.locationName);
      if (normalized) {
        const locationKey = `${this.indexKeyPrefix}:location:${normalized.canonical}`;
        pipeline.sadd(locationKey, String(doc.id));
      }
    }

    await pipeline.exec();
  }

  /**
   * Batch index multiple documents
   */
  async indexDocuments(docs: GeoIndexedDocument[]): Promise<void> {
    const client = await this.redis.getClient();
    const pipeline = client.pipeline();

    const mainGeoKey = `${this.indexKeyPrefix}:main`;

    for (const doc of docs) {
      if (!isValidCoordinates(doc.location)) {
        console.warn(`Skipping document ${doc.id} with invalid coordinates`);
        continue;
      }

      // Add to geo index
      pipeline.geoadd(mainGeoKey, doc.location.lng, doc.location.lat, String(doc.id));

      // Store document
      const docKey = `${this.indexKeyPrefix}:doc:${doc.id}`;
      const docData: any = {
        ...doc.data,
        _geo_lat: doc.location.lat,
        _geo_lng: doc.location.lng,
      };

      if (doc.locationName) {
        docData._geo_location_name = doc.locationName;
      }

      // Auto-assign bucket if enabled
      if (this.config.buckets) {
        const bucket = findBucket(doc.location, this.config.buckets);
        if (bucket) {
          docData._geo_bucket_id = bucket.id;
          const bucketKey = `${this.indexKeyPrefix}:bucket:${bucket.id}`;
          pipeline.sadd(bucketKey, String(doc.id));
        }
      }

      pipeline.set(docKey, JSON.stringify(docData));

      // Location name indexing
      if (doc.locationName && this.config.autoNormalize) {
        const normalized = this.locationNormalizer.normalize(doc.locationName);
        if (normalized) {
          const locationKey = `${this.indexKeyPrefix}:location:${normalized.canonical}`;
          pipeline.sadd(locationKey, String(doc.id));
        }
      }
    }

    await pipeline.exec();
  }

  /**
   * Search for documents within a radius
   */
  async searchByRadius(options: GeoSearchOptions): Promise<GeoSearchResult[]> {
    const client = await this.redis.getClient();
    const mainGeoKey = `${this.indexKeyPrefix}:main`;

    // Convert radius to meters for Redis GEORADIUS
    let radiusM: number;
    switch (options.radius.unit) {
      case 'km':
        radiusM = options.radius.value * 1000;
        break;
      case 'mi':
        radiusM = options.radius.value * 1609.34;
        break;
      default:
        radiusM = options.radius.value;
    }

    // Perform geo search
    const results = await client.georadius(
      mainGeoKey,
      options.center.lng,
      options.center.lat,
      radiusM,
      'm',
      'WITHDIST',
      'ASC', // Sort by distance
      ...(options.limit ? ['COUNT', options.limit] : [])
    );

    // Process results
    const geoResults: GeoSearchResult[] = [];

    for (const result of results) {
      const [id, distanceStr] = result as [string, string];
      const distance = parseFloat(distanceStr);

      // Fetch document data
      const docKey = `${this.indexKeyPrefix}:doc:${id}`;
      const docDataStr = await client.get(docKey);

      if (!docDataStr) continue;

      const docData = JSON.parse(docDataStr);

      // Extract geo metadata
      const {
        _geo_lat,
        _geo_lng,
        _geo_location_name,
        _geo_bucket_id,
        ...documentData
      } = docData;

      // Calculate relevance score based on distance
      const maxDistance = radiusM;
      const distanceScore = 1 - distance / maxDistance;

      // Apply distance boost if configured
      let boost = 1.0;
      if (options.distanceBoost) {
        for (const boostConfig of options.distanceBoost) {
          const boostDistanceM = this.convertToMeters(boostConfig.distance);
          if (distance <= boostDistanceM) {
            boost = Math.max(boost, boostConfig.boost);
          }
        }
      }

      const relevanceScore = distanceScore * boost;

      // Get bucket if available
      let bucket: GeoBucket | undefined;
      if (_geo_bucket_id && this.config.buckets) {
        bucket = this.config.buckets.find((b) => b.id === _geo_bucket_id);
      }

      geoResults.push({
        document: documentData,
        distance: options.includeDistance !== false ? {
          value: this.convertFromMeters(distance, options.radius.unit),
          unit: options.radius.unit,
        } : undefined,
        bucket,
        relevanceScore,
      });
    }

    return geoResults;
  }

  /**
   * Search by location name (with normalization)
   */
  async searchByLocationName(
    locationName: string,
    options?: Partial<GeoSearchOptions>
  ): Promise<GeoSearchResult[]> {
    // Normalize location name
    const normalized = this.locationNormalizer.normalize(locationName);

    if (!normalized || !normalized.coordinates) {
      // Try to get from bucket
      const bucket = this.locationNormalizer.getBucket(locationName);
      if (bucket) {
        // Search within bucket
        return this.searchByRadius({
          center: bucket.center,
          radius: bucket.radius,
          ...options,
        } as GeoSearchOptions);
      }

      throw new Error(`Cannot find coordinates for location: ${locationName}`);
    }

    // Use normalized coordinates for search
    const radius = options?.radius || this.config.defaultRadius || { value: 25, unit: 'km' };

    return this.searchByRadius({
      center: normalized.coordinates,
      radius,
      includeDistance: true,
      sortByDistance: true,
      ...options,
    } as GeoSearchOptions);
  }

  /**
   * Search within a specific bucket
   */
  async searchByBucket(bucketId: string, limit?: number): Promise<GeoSearchResult[]> {
    const bucket = this.config.buckets?.find((b) => b.id === bucketId);
    if (!bucket) {
      throw new Error(`Bucket not found: ${bucketId}`);
    }

    return this.searchByRadius({
      center: bucket.center,
      radius: bucket.radius,
      bucketId,
      limit,
      includeDistance: true,
    });
  }

  /**
   * Build geo-buckets with dynamic clustering
   */
  async buildGeoBuckets(options: {
    targetBucketSize: number;
    gridSizeKm: number;
    minBucketSize: number;
  }): Promise<{
    totalBuckets: number;
    buckets: GeoBucket[];
    avgBucketSize: number;
  }> {
    const client = await this.redis.getClient();
    const mainGeoKey = `${this.indexKeyPrefix}:main`;

    // 1. Fetch all document IDs and their coordinates
    const allMembers = await client.zrange(mainGeoKey, 0, -1);
    if (allMembers.length === 0) {
      return { totalBuckets: 0, buckets: [], avgBucketSize: 0 };
    }

    // 2. Fetch coordinates for all members
    const pipeline = client.pipeline();
    for (const memberId of allMembers) {
      pipeline.geopos(mainGeoKey, memberId);
    }
    const positions = await pipeline.exec();

    // 3. Build document records
    const records: Array<{
      id: string;
      lat: number;
      lng: number;
      locationName?: string;
    }> = [];

    for (let i = 0; i < allMembers.length; i++) {
      const pos = positions![i][1] as [string, string] | null;
      if (!pos) continue;

      const [lngStr, latStr] = pos;
      const lng = parseFloat(lngStr);
      const lat = parseFloat(latStr);

      // Fetch location name if available
      const docKey = `${this.indexKeyPrefix}:doc:${allMembers[i]}`;
      const docDataStr = await client.get(docKey);
      let locationName: string | undefined;

      if (docDataStr) {
        const docData = JSON.parse(docDataStr);
        locationName = docData._geo_location_name;
      }

      records.push({ id: allMembers[i], lat, lng, locationName });
    }

    // 4. Create grid-based clusters
    const gridSizeDeg = options.gridSizeKm / 111; // Approximate km to degrees
    const gridCells = new Map<string, typeof records>();

    for (const record of records) {
      const cellLat = Math.floor(record.lat / gridSizeDeg) * gridSizeDeg;
      const cellLng = Math.floor(record.lng / gridSizeDeg) * gridSizeDeg;
      const cellKey = `${cellLat.toFixed(4)},${cellLng.toFixed(4)}`;

      if (!gridCells.has(cellKey)) {
        gridCells.set(cellKey, []);
      }
      gridCells.get(cellKey)!.push(record);
    }

    // 5. Process cells into buckets
    const buckets: GeoBucket[] = [];
    let bucketIdCounter = 1;

    for (const [cellKey, cellRecords] of gridCells.entries()) {
      if (cellRecords.length < options.minBucketSize) {
        // Too few items, skip or merge later
        continue;
      }

      if (cellRecords.length > options.targetBucketSize * 3) {
        // Cell too large, subdivide using k-means
        const numClusters = Math.ceil(cellRecords.length / options.targetBucketSize);
        const subClusters = this.kMeansClustering(cellRecords, numClusters);

        for (const cluster of subClusters) {
          if (cluster.length >= options.minBucketSize) {
            buckets.push(this.createBucket(cluster, bucketIdCounter++));
          }
        }
      } else {
        // Cell size is reasonable
        buckets.push(this.createBucket(cellRecords, bucketIdCounter++));
      }
    }

    // 6. Store buckets in Redis
    const storePipeline = client.pipeline();

    // Clear existing buckets
    const oldBucketKeys = await client.keys(`${this.indexKeyPrefix}:bucket:*`);
    if (oldBucketKeys.length > 0) {
      storePipeline.del(...oldBucketKeys);
    }

    // Store new buckets
    for (const bucket of buckets) {
      const bucketKey = `${this.indexKeyPrefix}:bucket:${bucket.id}`;
      const bucketDataKey = `${this.indexKeyPrefix}:bucket-data:${bucket.id}`;

      // Store member IDs (only if members exist)
      if (bucket.members && bucket.members.length > 0) {
        storePipeline.sadd(bucketKey, ...bucket.members);
      }

      // Store bucket metadata
      storePipeline.set(bucketDataKey, JSON.stringify({
        id: bucket.id,
        center: bucket.center,
        radius: bucket.radius,
        count: bucket.members?.length || 0,
        locationName: bucket.locationName,
        bounds: bucket.bounds,
      }));
    }

    await storePipeline.exec();

    // Calculate stats
    const totalItems = buckets.reduce((sum, b) => sum + (b.members?.length || 0), 0);
    const avgBucketSize = buckets.length > 0 ? totalItems / buckets.length : 0;

    return {
      totalBuckets: buckets.length,
      buckets,
      avgBucketSize: parseFloat(avgBucketSize.toFixed(1)),
    };
  }

  /**
   * Get all geo-buckets for this table
   */
  async getGeoBuckets(): Promise<Array<{
    id: string;
    center: GeoPoint;
    radius: GeoDistance;
    count: number;
    locationName?: string;
    bounds?: any;
  }>> {
    const client = await this.redis.getClient();
    const bucketDataKeys = await client.keys(`${this.indexKeyPrefix}:bucket-data:*`);

    if (bucketDataKeys.length === 0) {
      return [];
    }

    const pipeline = client.pipeline();
    for (const key of bucketDataKeys) {
      pipeline.get(key);
    }

    const results = await pipeline.exec();
    const buckets: any[] = [];

    for (const result of results!) {
      const bucketDataStr = result[1] as string;
      if (bucketDataStr) {
        buckets.push(JSON.parse(bucketDataStr));
      }
    }

    return buckets;
  }

  /**
   * Simple k-means clustering
   */
  private kMeansClustering(
    records: Array<{ id: string; lat: number; lng: number; locationName?: string }>,
    k: number
  ): Array<typeof records> {
    if (records.length <= k) {
      return records.map(r => [r]);
    }

    // Initialize centroids randomly
    const centroids: Array<{ lat: number; lng: number }> = [];
    const usedIndices = new Set<number>();

    for (let i = 0; i < k; i++) {
      let idx: number;
      do {
        idx = Math.floor(Math.random() * records.length);
      } while (usedIndices.has(idx));
      usedIndices.add(idx);
      centroids.push({ lat: records[idx].lat, lng: records[idx].lng });
    }

    // Iterate until convergence (max 20 iterations)
    for (let iter = 0; iter < 20; iter++) {
      // Assign records to nearest centroid
      const clusters: Array<typeof records> = Array.from({ length: k }, () => []);

      for (const record of records) {
        let minDist = Infinity;
        let nearestCluster = 0;

        for (let i = 0; i < k; i++) {
          const dist = calculateDistance(
            { lat: record.lat, lng: record.lng },
            centroids[i]
          );
          if (dist < minDist) {
            minDist = dist;
            nearestCluster = i;
          }
        }

        clusters[nearestCluster].push(record);
      }

      // Recalculate centroids
      let changed = false;
      for (let i = 0; i < k; i++) {
        if (clusters[i].length === 0) continue;

        const newLat = clusters[i].reduce((sum, r) => sum + r.lat, 0) / clusters[i].length;
        const newLng = clusters[i].reduce((sum, r) => sum + r.lng, 0) / clusters[i].length;

        if (Math.abs(newLat - centroids[i].lat) > 0.0001 || Math.abs(newLng - centroids[i].lng) > 0.0001) {
          changed = true;
        }

        centroids[i] = { lat: newLat, lng: newLng };
      }

      if (!changed) break;
    }

    // Return clusters with at least one member
    const clusters: Array<typeof records> = Array.from({ length: k }, () => []);
    for (const record of records) {
      let minDist = Infinity;
      let nearestCluster = 0;

      for (let i = 0; i < k; i++) {
        const dist = calculateDistance(
          { lat: record.lat, lng: record.lng },
          centroids[i]
        );
        if (dist < minDist) {
          minDist = dist;
          nearestCluster = i;
        }
      }

      clusters[nearestCluster].push(record);
    }

    return clusters.filter(c => c.length > 0);
  }

  /**
   * Create a bucket from a cluster of records
   */
  private createBucket(
    records: Array<{ id: string; lat: number; lng: number; locationName?: string }>,
    bucketId: number
  ): GeoBucket {
    // Calculate centroid
    const centerLat = records.reduce((sum, r) => sum + r.lat, 0) / records.length;
    const centerLng = records.reduce((sum, r) => sum + r.lng, 0) / records.length;
    const center: GeoPoint = { lat: centerLat, lng: centerLng };

    // Calculate max distance from center (for radius)
    let maxDist = 0;
    for (const record of records) {
      const dist = calculateDistance(center, { lat: record.lat, lng: record.lng });
      maxDist = Math.max(maxDist, dist);
    }

    // Add 10% buffer to radius
    const radiusKm = maxDist * 1.1;

    // Calculate bounding box
    const lats = records.map(r => r.lat);
    const lngs = records.map(r => r.lng);
    const bounds: GeoBounds = {
      northEast: {
        lat: Math.max(...lats),
        lng: Math.max(...lngs),
      },
      southWest: {
        lat: Math.min(...lats),
        lng: Math.min(...lngs),
      },
    };

    // Determine primary location name (most common)
    const locationCounts: Record<string, number> = {};
    for (const record of records) {
      if (record.locationName) {
        const loc = record.locationName.toLowerCase();
        locationCounts[loc] = (locationCounts[loc] || 0) + 1;
      }
    }

    const locationName = Object.keys(locationCounts).length > 0
      ? Object.entries(locationCounts)
          .sort(([, a], [, b]) => b - a)[0][0]
      : undefined;

    return {
      id: `bucket_${bucketId}`,
      center,
      radius: { value: radiusKm, unit: 'km' },
      members: records.map(r => r.id),
      locationName,
      bounds,
    };
  }

  /**
   * Get index statistics
   */
  async getStats(): Promise<GeoIndexStats> {
    const client = await this.redis.getClient();
    const mainGeoKey = `${this.indexKeyPrefix}:main`;

    // Get total documents
    const totalDocuments = await client.zcard(mainGeoKey);

    // Get bucket counts
    const bucketCounts: Record<string, number> = {};
    if (this.config.buckets) {
      for (const bucket of this.config.buckets) {
        const bucketKey = `${this.indexKeyPrefix}:bucket:${bucket.id}`;
        const count = await client.scard(bucketKey);
        bucketCounts[bucket.id] = count;
      }
    }

    // Calculate geographic bounds (would require fetching all docs - expensive)
    // For now, return null and calculate on demand if needed
    const bounds = {
      northEast: { lat: 90, lng: 180 },
      southWest: { lat: -90, lng: -180 },
    };

    // Get index size estimate
    const keys = await client.keys(`${this.indexKeyPrefix}:*`);
    let indexSize = 0;
    for (const key of keys.slice(0, 100)) { // Sample first 100 keys
      const memory = await client.memory('USAGE', key);
      if (memory) indexSize += memory;
    }
    indexSize = Math.round((indexSize / Math.min(keys.length, 100)) * keys.length);

    return {
      totalDocuments,
      bucketCounts,
      bounds,
      normalizedLocations: this.locationNormalizer.getStats().totalCanonical,
      indexSize,
      lastUpdated: new Date(),
    };
  }

  /**
   * Clear all geo indexes for this table
   */
  async clearIndex(): Promise<void> {
    const client = await this.redis.getClient();
    const keys = await client.keys(`${this.indexKeyPrefix}:*`);

    if (keys.length > 0) {
      await client.del(...keys);
    }
  }

  /**
   * Helper: Convert distance to meters
   */
  private convertToMeters(distance: GeoDistance): number {
    switch (distance.unit) {
      case 'km':
        return distance.value * 1000;
      case 'mi':
        return distance.value * 1609.34;
      default:
        return distance.value;
    }
  }

  /**
   * Helper: Convert meters to target unit
   */
  private convertFromMeters(meters: number, unit: 'km' | 'mi' | 'm'): number {
    switch (unit) {
      case 'km':
        return meters / 1000;
      case 'mi':
        return meters / 1609.34;
      default:
        return meters;
    }
  }
}
